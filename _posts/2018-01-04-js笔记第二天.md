---
load: post
title: js笔记第二天
date: 2018-01-04
header-img: img/post-bg-desk.jpg
catalog: true
tags: JavaScript
---

### 数字类型　number

>   0 12 -12 9.2 ,number有一个特殊类型：`NaN`

```js
typeof NaN;//"number"
```

`isNaN` 用来检测数据值是否是非有效数字，如果是有效数字，返回 `false`,反之，返回 `true`.

`Number()` 强制转换，将其他数据类型转换为number类型

关于数据类型的转换，[->详细...](http://javascript.ruanyifeng.com/grammar/conversion.html)

`parseInt()` 提取字符串中的整数，遇到第一个非数字则返回`NaN`

`parseInt()` 函数在转换字符串时，会忽略字符串前面的空格，知道找到第一个非空格字符。

>   如果第一个字符不是数字或者负号，`parseInt()` 就会返回 `NaN`，同样的，用 `parseInt()` 转换空字符串也会返回 `NaN`。
>
>   如果第一个字符是数字字符，`parseInt()` 会继续解析第二个字符，直到解析完所有后续字符串或者遇到了一个非数字字符。
>
>   **`parseInt()`方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。**
>
>   基是由 `parseInt()` 方法的第二个参数指定的，所以要解析十六进制的值，当然，对二进制、八进制，甚至十进制（默认模式），都可以这样调用`parseInt()` 方法。



`parseFloat()` 提取字符串中的整数及其小数部分

>   `parseFloat()` 也是从第一个字符（位置`0`）开始解析每一个字符。也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。
>
>   也就是说，字符串中第一个小数点是有效的，而第二个小数点就是无效的了，它后面的字符串将被忽略。`parseFloat()` 只解析十进制，因此它没有第二个参数指定基数的用法.
>
>   如果字符串中包含的是一个可解析为正数的数（没有小数点，或者小数点后都是零），`parseFloat()` 会返回整数。

`toFixed()` 可把 **Number** 四舍五入为指定小数位数的数字。

**语法**

```js
NumberObject.toFixed(num)//返回NumberObject保留指定小数位且四舍五入后的字符串模式
```

>   如果省略参数，不会保留小数位，并且四舍五入。

## 对象数据类型 object

对象：属性和方法的集合。

属性名可以是字母、数字，属性值可以任意类型：

```js
var obj = {name:"老贼",age:10000,1:1,"skill type":["前端","后端"]}
```

### 访问对象的属性

两种方式：

-   点 `.` 操作符

```js
console.log(obj.name);
// 但用 . 操作符 访问不了数字类型的属性名和有空格的字符串属性名：
console.log(obj.1);//Uncaught SyntaxError: Unexpected number
console.log(obj.skill type);//Uncaught SyntaxError: Unexpected identifier
```

-   `[]` 操作符

```js
// 数字类型或者有空格的字符串属性名必须用[]来访问
console.log(obj["1"]);// 如果是数字，obj[1]也可以访问，但是建议加上引号
console.log(obj["skill type"]);
```

如果访问一个不存在的属性，返回 `undefined`

### 增加属性

如果给当前对象不存在的属性赋值，会给当前对象增加一个属性，并赋值

```js
obj.sex;//undefined
obj.sex="男";
console.log(obj);//{1: 1, name: "sunw", age: 1, skill type: Array(2), sex: "男"}
```

### 修改属性名

重新赋值即可

### 删除属性

**假删除**:设置属性值为 `null`,但属性还存在，只是值为空

**真删除**:对象的属性不存在，举例，`delete obj.name` 或 `delete obj["name"]`

## 基本数据类型和引用数据类型区别

------

[->来源](https://www.jianshu.com/p/a32fe1c964c1)

**数据类型**

1.  ECMAScript变量包含两种不同类型的值：基本类型值、引用类型值；
2.  基本类型值：指的是保存在**栈**内存中的简单数据段；
3.  引用类型值：指的是那些保存在**堆**内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值；

**两种访问方式**

1.  基本类型值：**按值访问**，操作的是他们实际保存的值；

2.  引用类型值：按引用访问，当查询时，我们需要先从栈中读取内存地址，然后再顺藤摸瓜地找到保存在堆内存中的值；

    ​

    ​

    ![img](http://upload-images.jianshu.io/upload_images/67090-a3fecb055ffebaf8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/484)

    ​

**两种类型复制**
基本类型变量的复制：  
从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上，**改变源数据不会影响到新的变量**（互不干涉）；  
引用类型变量的复制：  
**复制的是存储在栈中的指针**，将指针复制到栈中为新变量分配的空间中，而这个指针副本和原指针执行存储在堆中的同一个对象，复制操作结束后，两个变量实际上将引用同一个对象；因此**改变其中的一个，将影响另一个**；  

**函数参数的传递**  
**1、ECMA中所有函数的参数都是按值传递的**  
在向参数传递基本类型的值时，被传递的值会被复制给一个**局部变量**，在向参数传递引用类型的值时，会把这个值在内存的地址复制给一个**局部变量**  
基本数据类型传递参数   

```js
funciton addTen(num){
  num+=10;
  return num;
}
var count=20;
var result=addTen(count);
alert(count);//20
alert(resullt);//30
```

执行结果是：20和30。  
在这段代码中，将变量`count`当做参数传递给了函数`addTen`，也就是相当于将变量`count`的值复制给了函数`addTen`的参数。这时`addTen`的参数`num`可以看做是函数内部的一个变量。  
在上段代码中，就相当于两个基本数据类型变量之间的值复制。而基本数据类型都有自己独立的内存地址，所以`num`和`count`是没有任何关系的，他们只是值相等而已，函数执行完毕后，`count`的值并没有改变。  
而函数外面的`result`是被直接赋值的，所以`result`的值就是函数的结果30。  

引用类型传递参数  

```js
function setName(obj){
  obj.name="LSN";
}
var person=new Object();
setName(person);
alert(person.name); // LSN
```

执行结果是：LSN。  
在这段代码中，函数`setName`的作用是给`obj`对象添加了一个属性`name`，并给该属性赋值为"LSN"，因为`obj`是引用类型，所以这里属于是将引用类型`person`赋值给了`obj`，也就是说`person`和`obj`引用了一个内存地址，所以当给`obj`新加了属性`name`时，在函数外面的`person`也跟着改变，最后`person.name`的结果为LSN。   

**引用类型传递参数到底传的是值还是引用**

```js
function setName(obj){
  obj.name="ABC";
  obj=new Object();
  obj.name="BCD";
}
var person=new Object();
setName(person);
alert(person.name); // ABC
```

执行结果是：ABC。  
实例3与实例2的区别是在函数中又加了2行代码，在给`obj`对象新加一个属性`name`并赋值后又将`obj`定义成了一个新的对象（`new Object()`），定义新对象后又`name`赋上新的值“BCD”。  
这个时候如果是按引用传递的话，那么最后`person`对象就会自动修改为指向其`name`属性为"BCD"的新对象，但最后显示的却是“ABC”，这说明即使在函数内部修改了参数的值，但原始的引用还保持不变。  
实际上，当在函数内部`obj=new Object()`时 这个新的`obj`就已经成为函数内部的局部对象了，这个对象会在函数执行完毕后等待GC销毁。

**两种变量类型检测**

1.  `typeof` 操作符是检测基本类型的最佳工具；
2.  **如果变量值是nul或者对象，typeof 将返回“object”；**
3.  `instanceof` 用于检测引用类型，可以检测到具体的，它是什么类型的实例；
4.  如果变量是给定引用类型的实例，`instanceof` 操作符会返回 `true`;

**补充：基本包装类型(包装对象)**
先看下以下代码：

```js
var s1 = "helloworld";
var s2 = s1.substr(4);
```

上面我们说到字符串是基本数据类型，不应该有方法，那为什么这里 `s1` 可以调用 `substr()` 呢？  
ECMAScript 还提供了三个特殊的引用类型 `Boolean`，`String`，`Number`.我们称这三个特殊的引用类型为**基本包装类型**，也叫**包装对象**。  

也就是说当读取 `string`，`boolean` 和 `number` 这三个基本数据类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据.  

所以当第二行代码访问 `s1` 的时候，后台会自动完成下列操作：

-   创建String类型的一个实例；`// var s1 = new String("helloworld");`
-   在实例上调用指定方法；`// var s2 = s1.substr(4);`
-   销毁这个实例；`// s1 = null;`

正因为有第三步这个销毁的动作，所以基本数据类型不可以添加属性和方法，这也正是基本装包类型和引用类型主要区别：**对象的生存期**。  

**使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都是一直保存在内存中。自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。**

------

## 函数数据类型 function

具有一定功能的方法。

函数实际上是对象。每个函数都是Function类型的实例，而且跟其他引用类型一样具有属性和方法。**函数名实际上是一个指向函数对象的指针**。

函数定义：

1.  声明式定义 function foo(){}
2.  表达式定义 var foo = function(){}
3.  构造函数式 var foo = new Function();// 最好放弃治疗

执行函数 *函数名();*

## == 运算符

`==` 运算符一般是先判断左右的类型(Type)：

-   **如果类型相同**：
    -   如果类型是`undefined`,那么 `undefined==undefined;//true`
    -   若类型是 `null`,那么 `null==null;//true`
    -   若类型是 `number`,那么：
        -   `NaN==NaN;//false`
        -   左右值是相同的number，返回 `true`
        -   `+0` 永远等于 `-0`
        -   其他均返回 `false`
    -   若是 `string` 类型，相同的字符串返回 `true`,否则`false`
    -   若是 `boolean` 类型，左右相同返回 `true`,否则 `false`
    -   若是 `object` 类型，左右引用地址相同，返回 `true`,否则 `false`
-   **左右类型不同**：
    -   `null==undefined;//true` `undefined==null;//true`
    -   若是 `string` 或 `boolean` 和 `number` 比较，需要对 `string` 或 `boolean` 用 `Number()` 强转 
    -   若两侧只有一侧是 `object`,而另一侧既不是 `string`,也不是`number`，则需要返回 `object` 的原始值和另一侧比较

一个特殊情况：`null==undefined`//true [->原因...](https://stackoverflow.com/questions/16607761/why-null-undefined-is-true-in-javascript)

ECMA-262关于 `==` 的说明:

>   # The Abstract Equality Comparison Algorithm
>
>   The comparison x == y, where x and y are values, produces **true** or **false**. Such a comparison is performed as follows:
>
>   1.  If Type (x) is the same as Type (y), then
>       1.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is Undefined, return **true**.
>       2.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is Null, return **true**.
>       3.  If Type (x) is Number, then
>           1.  If *x* is **NaN**, return **false**.
>           2.  If *y* is **NaN**, return **false**.
>           3.  If *x* is the same Number value as *y*, return **true**.
>           4.  If *x* is **+0** and *y* is **−0**, return **true**.
>           5.  If *x* is **−0** and *y* is **+0**, return **true**.
>           6.  Return **false**.
>       4.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is String, then return **true** if *x* and *y* are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return **false**.
>       5.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is Boolean, return **true** if *x* and *y* are both **true** or both **false**. Otherwise, return **false**.
>       6.  Return **true** if *x* and *y* refer to the same object. Otherwise, return **false**.
>   2.  If *x* is **null** and *y* is **undefined**, return **true**.
>   3.  If *x* is **undefined** and *y* is **null**, return **true**.
>   4.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is Number and [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*y*) is String,
>       return the result of the comparison *x* == [ToNumber](http://www.ecma-international.org/ecma-262/5.1/#sec-9.3)(*y*).
>   5.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is String and [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*y*) is Number,
>       return the result of the comparison [ToNumber](http://www.ecma-international.org/ecma-262/5.1/#sec-9.3)(*x*) == *y*.
>   6.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is Boolean, return the result of the comparison [ToNumber](http://www.ecma-international.org/ecma-262/5.1/#sec-9.3)(*x*) == *y*.
>   7.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*y*) is Boolean, return the result of the comparison *x* == [ToNumber](http://www.ecma-international.org/ecma-262/5.1/#sec-9.3)(*y*).
>   8.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is either String or Number and [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*y*) is Object,
>       return the result of the comparison *x* == [ToPrimitive](http://www.ecma-international.org/ecma-262/5.1/#sec-9.1)(*y*).
>   9.  If [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*x*) is Object and [Type](http://www.ecma-international.org/ecma-262/5.1/#sec-8)(*y*) is either String or Number,
>       return the result of the comparison [ToPrimitive](http://www.ecma-international.org/ecma-262/5.1/#sec-9.1)(*x*) == *y*.
>   10.  Return **false**.
>
>   **NOTE 1** Given the above definition of equality:
>
>   -   String comparison can be forced by: `"" + a == "" + b`.
>   -   Numeric comparison can be forced by: `+a == +b`.
>   -   Boolean comparison can be forced by: `!a == !b`.
>
>   **NOTE 2** The equality operators maintain the following invariants:
>
>   -   `A` `!=` `B` is equivalent to `!(A` `==` `B)`.
>   -   `A` `==` `B` is equivalent to `B` `==` `A`, except in the order of evaluation of `A` and `B`.
>
>   **NOTE 3** The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the `==` operator, but the two String objects would not be equal to each other. For Example:
>
>   -   `new String("a")` `==` `"a"` and `"a"` `==` `new String("a")`are both **true**.
>   -   `new String("a")` `==` `new String("a")` is **false**.
>
>   **NOTE 4** Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.

[->MDN 上 `==` 的解释...](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)

## 条件语句 

### if-else

```js
if(condition1){
  statement1...
}else if(condition2){
  statement2...
}....else{
  statement...
}
  //condition 会调用 Boolean() 方法
```

**三元运算符**:`expression1?expression2:expression3;` 适用于简单的 `if-else`,非此即彼型。

`!!expression` 相当于 `Boolean(expression)` 相当于`expression?true:false`

```js
condition?statement1:statement2;
```

### switch-case

用于一个变量或表达式(`case`)有多个值的情况，相较于 `if-else`结构更加清晰。

```js
switch(case){
  case val1:statement1...;break;
  case val2:statement2...;break;
    	...
  case valn:statementn...;break;
  default:statement...;
}
```

`default` 语句，当所有条件都不满足(case 的值与 case 子句val1..valn **严格相等**的)的情况下，执行 default 语句。

`default` 语句可选，但是一般建议写上。

如果不写 `break` 语句，语句将一直执行，直到遇到下一个 break 语句或者 default，然后跳出代码执行环境。

**switch中的相等判断用严格相等 `===`**

[->switch更多资料](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/switch)


---
load: post
title: js笔记第三天
date: 2018-01-06
header-img: img/post-bg-desk.jpg
catalog: true
tags: JavaScript
---

## Array 数组

数组是对象类型中细分出来的一种类型，把对象中属性名是数字的全部拿出来，再经过内部的处理独立成数组类型。

对象的元素部分顺序，但是数组的元素是有序排列的。它的 “属性名” 是从 0 开始依次递增的数字，称为**索引**。

### 定义数组：

-   字面量方式

    ```js
    var arr = ["a",34,{name:"kk",age:23}];
    ```

-   构造函数方式

    ```js
    var arr = new Array();
    ```

### 数组中的方法

从以下四个维度理解数组方法：

1.  方法的含义
2.  方法需不需要传参
3.  方法有没有返回值
4.  原数组是否改变

根据是否修改原数组把数组方法分为两大类：

**会修改原数组的方法：**

| 方法                | 功能                                       | 参数                                       | 返回值                          | 备注                          |
| ----------------- | ---------------------------------------- | ---------------------------------------- | ---------------------------- | --------------------------- |
| `push()`          | 向数组**尾部**添加元素                            | 要添加的元素                                   | 新数组的`length`                 | 相当于`arr[arr.length]=value;` |
| `unshift()`       | 向数组**头部**添加元素                            | 要添加的元素                                   | 新数组的 `length`                |                             |
| `pop()`           | 删除数组**尾部**的**一个**元素                      |                                          | 被删除的元素                       | 相当于`arr.length--;`          |
| `shift()`         | 删除数组**头部**的**一个**元素                      |                                          | 被删除的元素                       |                             |
| `splice(n,m,[x])` | 从索引`n`开始删除`m`项，然后用`x`的内容**替换**删除的内容，这里的替换可能增加原数组长度:如果`m==0`,插入的元素在`n`的前边 | `n,m`必须;`x`可选；                           | 被删除的元素构成的**数组**，如果没有删除返回`[]` |                             |
| `reverse()`       | 反向排列                                     |                                          | 反转后的数组                       |                             |
| `sort()`          | 对数组做各种**有序**排列                           | 1. 不传参，默认ascii 顺序排列，只能对10以内的数字排序<br />2.参数为回调函数：`function(a,b){return a-b}`,若返回`a-b`,升序；若返回`b-a`,降序。 | 重新排序后的数组                     |                             |

**不会改变原数组的方法：**

| 方法                   | 功能                                | 参数                                       | 返回值              | 备注                         |
| -------------------- | --------------------------------- | ---------------------------------------- | ---------------- | -------------------------- |
| `toString()`         | 调用数组每一个元素的`toString`方法，拼接为一个字符串输出 |                                          | 字符串              |                            |
| `join([character])`  | 按照指定字符，将数组的每一项拼接成字符串              | 可选字符                                     | 指定字符拼接成的字符串      | 不传参，默认以`,`拼接               |
| `concat()`           | 拼接一个新的数组                          | 任何数据类型                                   | 拼接后的数组           | 如果参数是一个数组，会把数组中的元素提取出来然后拼接 |
| `slice(start,[end])` | 截取数组                              | 从索引`start`截取到索引`end`,`end`可选，若不选`end`,将截取到末尾;<br />若索引值为负数，从末尾开始计算 | 截取后的数组           | 在js中涉及到区间范围，一般都是前闭后开：`[)`  |
| `indexOf()`          | 从数组头部开始查找数组某一个元素的位置               | 数组中某元素                                   | 查找到返回索引值，查不到返回-1 | 用来判断数组中元素是否存在              |
| `lastIndexOf()`      | 从数组尾部开始查找数组某一个元素的位置               | 数组中某元素                                   | 查找到返回索引值，查不到返回-1 | IE8-不支持                    |

### 算法

####  冒泡排序

```js
function bubbleSort(arr) {
  if (Array.isArray(arr)) {
    for (var j = 0; j < arr.length - 1; j++) {
      var temp = null;
      for (var i = 0; i < arr.length - 1 - j; i++) {
        if (arr[i] > arr[i + 1]) {
          temp = arr[i];
          arr[i] = arr[i + 1];
          arr[i + 1] = temp;
        }
        index++;
        console.log("循环第" + index + "次");
      }
    }
  }
  return arr;
}

console.log(bubbleSort([1, 3, 2, 2, 0]));
```



#### 数组去重

双循环

```js
function removeDuplication(arr) {
  if(Array.isArray(arr))
    for(var i=0;i<arr.length-1;i++){
      for(var j=i+1;j<arr.length;j++){
        if(arr[i]===arr[j]){
          arr.splice(j,1);//数组塌陷
          j--;
        }
      }
    }
  return arr;
}
console.log(removeDuplication([1,5,2,1,2,3,4,3]));
```

以对象为中介

```js
function removeDuplication(arr) {
  if(Array.isArray(arr)){
    var obj = {};
    for(var i=0;i<arr.length;i++){
      if(obj[arr[i]]===arr[i]){
        arr.splice(i,1);
        i--;
      }else{
        obj[arr[i]]=arr[i];
      }
    }
    console.log(obj);
    obj=null;
  }
  return arr;
}

console.log(removeDuplication([1, {}, {}, [],[],3, 2,"a", 1,"a"]));
```

#### 递归调用

**快速排序**

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  var povitIndex = Math.floor(arr.length / 2);
  var povit = arr.splice(povitIndex,1)[0];// 删除中间元素组成一个新数组
  var left = [];
  var right = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < povit) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(povit, quickSort(right));
}

console.log(quickSort([1, 4, 2, 1, 54]));
```

### 插入排序

**splice()方法的使用**

```js
/**
* 插入排序：
* 先从需要排序的牌(arr[])中拿出一张牌放入左边(left[])，
* 之后每拿出一张牌，从右往左(倒序)跟左边的牌(left[])依次比较：
*
* 1.如果比左边最后一张牌大，则直接排在左边牌的最后边
* 2.如果比左边的最后一张牌小，则继续往前比较，直到遇到比自己小的牌则插入比自己小的牌之后
* 3.如果比左边第一张牌还小，则直接插入左边牌的最前边
*/
function insertSort(arr) {
  var left = arr.splice(0, 1);
  for (var i = 0; i < arr.length; i++) {
    for (var j = left.length - 1; j >= 0;) {
      if (arr[i] > left[j]) {
        // 在这里，splice 用来将元素插入两个元素之间，或者直接插入数组的末尾
        left.splice(j + 1, 0, arr[i]);
        break;
      } else {
        j--; //跟left数组的下一个元素比较
        if (j === -1) {
          left.unshift(arr[i]);
        }
      }
    }
  }
  return left;
}

var arr = [2, 4, 1, 34, 20, 9, 3];
console.log(insertSort(arr));
```


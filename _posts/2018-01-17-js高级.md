**keys:变量提升，作用域，this，面向对象**

## 作用域

当浏览器加载页面时，会形成一个全局作用域。

**作用域**：代码运行的环境，栈内存。

**全局变量**：运行在全局作用域中定义的变量。

>   （全局/私有作用域）不写 `var` 定义变量，会变成 `window` 的属性：
>
>   `a = 100;` 相当于 `window.a = 100;`
>
>   `console.log(a);` //  a is not defined 原因：浏览器认为 `a` 是一个值，必须知道 `a` 的数据类型

**私有作用域**：函数执行时，首先会形成私有作用域，供函数体中的代码执行，栈内存。函数每执行一次，会形成一个新的私有作用域。

**局部/私有变量**：在私有作用域定义的变量，一般是函数体中的变量和函数的形参。

>   函数体中可以访问外层作用域中的变量，但是外层作用域不能访问函数体中的变量。
>
>   标记查找从内往外寻找，如果找到停止查找，如果在最外层作用域都没有找到，报错。

私有作用域作用：

-   **闭包**：函数执行会形成一个私有作用域，保护函数体内的私有变量不受外部干扰。
-   存储值


全局变量与私有变量的案例：

```js
var a, b, fn = function () {
  var a = b = 10; // 相当于  var a = 10;b=10
};
fn();
console.log(a, b);// undefined  10
// 以上代码相当于
var a;//默认undefined
var b;//默认undefined
var fn = function(){
	var a = 10; // 重新定义了一个名为a的私有变量
  	b = 10; // 给全局变量 b 赋值 10
}
fn();
console.log(a,b);
```

## 变量提升

在当前作用域下，代码执行之前，把带 `var` 的和 `function` 的变量或者函数，放到当前作用域执行栈最前边。

带 `var` 的变量只声明不定义，只有当代码执行到赋值语句时才会定义(赋值)。

`function` 进行变量提升时，不仅进行声明，还要定义(赋值，因为在这里已经赋值， 在函数执行时会跳过代码中的函数)。所以函数的定义发生在变量提升阶段，而不是函数执行阶段。

函数表达式 `var fn = function(){}` 变量提升时看做变量而不是函数 `function`

函数的执行流程：

1.  形成一个私有作用域
2.  形参赋值
3.  变量提升
4.  代码从上到下执行
5.  作用域是否销毁

```js
function sum(num){
	console.log(num);
	function num(){}
	console.log(num);
}
sum(11);
//1.形成私有作用域
//2.形参赋值：num=11
//3.变量提升：num = function sum(){}
//4.运行：
```

特殊情况：

1.  不管条件是否成立，都要进行变量提升。

    ```js
    console.log(a);// undefined
    if(false){
    	var a = 10;//在全居中会提升
    }
    ```
    在新版本浏览器中，if 块中函数只声明不定义，在IE10及以下，if 块中函数不仅声明而且定义。
    ```js
    console.log(a);// undefined 
    console.log(fn);// 在标准浏览器中输出 undefined，IE10及以下输出函数本身
    if (false) {
      var a = 100;
      function fn() {
      }
    }
    // 一道关于变量提升的面试题
    f = function () {return true;};
    g = function () {
      return false;
    };
    ~function () {
      if (g() && [] == ![]) {// 标准浏览器输出 g is not a function；IE10及其以下浏览器继续执行
    f = function () {
      return false;
    };

    function g() {
      return true;
    }
      }
    }();
    console.log(f());// IE10及其以下浏览器 false 
    console.log(g());// IE10及其以下浏览器 false 
    ```

2.  变量提升只发生在等号 `=` 左边。

3.  `return` 返回的内容不进行提升,但是 `return` 语句之后的变量或者函数会提升。

    ```js
    function sum() {// 提升的内容 a c b
      var a = 10;
      console.log(b);// 整个函数 b
      console.log(c);//undefined
      return function () {
        console.log("hello");
      };
      console.log(b);// 此处代码不执行
      var c = 199;

      function b() {
        var d = 10;
      }
    }

    var f = sum();
    f();// hello
    ```

>   `return function(){};`// 这里 `return` 出去的是`function(){}`的堆内存地址。
>
>   `return` 返回的永远是一个值，如果 return 的是对象,返回的是对象的地址，若是基本数据类型的变量，则是原始值。

4.  如果变量名重复，不在进行声明，但是会重新定义。

    ```js
    console.log(a);// 函数
    var a = 100;
    console.log(a);// 100
    function a() {
    }
    // 变量提升：
    // 1. var a;
    // 2. a = function a (){} 不会重新声明，但是会重新赋值
    // 开始执行
    ```

5.  匿名函数不进行变量提升,自执行函数定义和执行一起完成

------

es6 中定义变量，通过 `let` 不进行变量提升。不容许重复声明。

`const` 定义**常量**，不容许修改值。

## 堆栈内存

```js
var ary=[1,2,3,4];
function f(ary){
  ary[0] = 0;
  arguments[0]=[];// 相当于ary=[],形参换了地址
  ary[0]=100;
  console.log(ary);//[100]
}
f(ary);
console.log(ary);//[0,2,3,4]
```

栈：存储基本数据类型    提供运行环境（作用域）

全局作用域销毁：关掉页面或者浏览器

私有作用域的销毁：一般情况下，函数执行完成后立即销毁，另外：

>   -   不销毁作用域：
>   1.  函数执行后 return 一个引用数据类型
>   2.  return 出去的内容被外界的变量或对象接收
>   -   不立即销毁作用域：
>   -   作用域销毁与否不仅与函数内部有关，还有函数执行有关：

堆：存储引用类型

## this 关键字

在作用域中有特殊意义：类似与指针，谁调用指向谁

1.  全局下的 `this`永远指向 `window`
2.  函数中的`this`要看函数执行前有没有`.`,`.` 前边是谁，`this` 就是谁;如果没有 `.`，`this` 指向 `window`
3.  给元素的事件行为绑定方法，那么方法中的 `this` 指向当前被绑定的元素
4.  自执行函数中的 `this` 永远指向 `window`
5.  回调函数中的 `this` 指向 `window`